[{"title":"Debian10设置开机自动登陆到桌面","date":"2022-01-15T13:58:10.000Z","url":"/Debian10%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E7%99%BB%E9%99%86%E5%88%B0%E6%A1%8C%E9%9D%A2/2022/01/15/","tags":[["Linux","/tags/Linux/"],["Debian10","/tags/Debian10/"]],"categories":[["undefined",""]],"content":"Debian10设置开机自动登陆到桌面 修改/etc/lightdm/lightdm.conf文件 修改/etc/lightdm/lightdm.conf文件 将 修改为 "},{"title":"Debian10开启ssh服务","date":"2022-01-15T13:48:10.000Z","url":"/Debian10%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1/2022/01/15/","tags":[["Linux","/tags/Linux/"],["Debian10","/tags/Debian10/"]],"categories":[["undefined",""]],"content":"Debian10开启ssh服务 安装ssh服务 修改sshd_config文件 启动SSH服务 验证SSH服务状态 添加开机自启动 安装ssh服务 修改sshd_config文件 将#PasswordAuthentication no的注释去掉，并且将no修改为yes将#PermitRootLogin prohibit-password的注释去掉，将prohibit-password改为yes 启动SSH服务 验证SSH服务状态 添加开机自启动"},{"title":"Debian10开机自启动","date":"2022-01-15T13:38:10.000Z","url":"/Debian10%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/2022/01/15/","tags":[["Linux","/tags/Linux/"],["Debian10","/tags/Debian10/"]],"categories":[["undefined",""]],"content":"Debian10开机自启动 将 autorun.sh 脚本放到 /etc/init.d/ 目录下 设置开机自启 取消开机自启 将 autorun.sh 脚本放到 /etc/init.d/ 目录下 设置开机自启 注意：可能出现以下错误 在autorun.sh文件头添加 然后重新执行 取消开机自启"},{"title":"Linux修改用户名和主机名","date":"2022-01-15T13:22:43.000Z","url":"/Linux%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%90%8D/2022/01/15/","tags":[["Linux","/tags/Linux/"]],"categories":[["undefined",""]],"content":"Linux修改用户名和主机名 修改用户名 切换root用户 修改/etc/passwd 修改/etc/group 修改/etc/gshadow 修改/etc/shadow 修改主目录 修改/etc/sudoers 重启 修改主机名 查看主机名 修改主机名 修改/etc/sysconfig/network 修改/etc/hosts 修改用户名切换root用户 修改/etc/passwd 将文件内所有的旧用户名替换成新用户名 修改/etc/group 将文件内所有的旧用户名替换成新用户名 修改/etc/gshadow 将文件内所有的旧用户名替换成新用户名 修改/etc/shadow 将文件内所有的旧用户名替换成新用户名 修改主目录 修改/etc/sudoers添加写权限 编辑/etc/sudoers 在root ALL=(ALL) ALL后添加新行&lt;新用户名&gt; ALL=(ALL) ALL 取消写权限 重启 修改主机名查看主机名 修改主机名 修改/etc/sysconfig/network 将文件内所有的旧主机名替换成新主机名 修改/etc/hosts 将文件内所有的旧主机名替换成新主机名，或添加新行127.0.0.1 &lt;新主机名&gt;"},{"title":"Linux下的超级终端terminator","date":"2022-01-08T13:43:40.000Z","url":"/Linux%E4%B8%8B%E7%9A%84%E8%B6%85%E7%BA%A7%E7%BB%88%E7%AB%AFterminator/2022/01/08/","tags":[["Linux","/tags/Linux/"],["好物推荐","/tags/%E5%A5%BD%E7%89%A9%E6%8E%A8%E8%8D%90/"]],"categories":[["undefined",""]],"content":"Linux下的超级终端terminator 安装 备注 terminator是一款Linux下的超级终端，可以自由多分屏 安装 备注本软件是基于python2的，如果遇到打开不了的情况，可以查看自己的默认python版本是不是python2 如果不是，可以修改/usr/bin/terminator文件，将第一行的#!/usr/bin/python改为#!/usr/bin/python2即可 "},{"title":"Hexo添加本地文件下载","date":"2021-12-15T13:16:28.000Z","url":"/Hexo%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/2021/12/15/","tags":[["Hexo","/tags/Hexo/"]],"categories":[["undefined",""]],"content":"Hexo添加本地文件下载 _config.yml配置 创建download文件夹 引用下载链接 备注 _config.yml配置将_config.yml文件中的post_asset_folder选项修改为true 创建download文件夹 在source下创建/download文件夹，把需要提供下载的文件复制到这个文件夹 引用下载链接最后在markdown文件中引入即可 备注目前未查明原因，谷歌浏览器点击下载链接，会直接打开，需要鼠标右击，链接另存为。。。"},{"title":"电路仿真circuitjs1","date":"2021-12-15T12:51:57.000Z","url":"/%E7%94%B5%E8%B7%AF%E4%BB%BF%E7%9C%9Fcircuitjs1/2021/12/15/","tags":[["好物推荐","/tags/%E5%A5%BD%E7%89%A9%E6%8E%A8%E8%8D%90/"]],"categories":[["undefined",""]],"content":"电路仿真circuitjs1 circuitjs1是一款基于html5的电路模拟器，开源，免费 github地址： windows汉化版： circuitjs1-win.zip linux汉化版： circuitjs1-linux64.tgz "},{"title":"WIN10查看端口占用情况","date":"2021-12-15T12:29:17.000Z","url":"/WIN10%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5/2021/12/15/","tags":[["WIN10","/tags/WIN10/"]],"categories":[["undefined",""]],"content":"WIN10查看端口占用情况 win+r，输入cmd打开控制台，输入 可查询到与此端口相关的程序PID 可查询到此PID的程序名称 可以关闭该程序"},{"title":"Python语音对讲","date":"2021-12-15T12:03:49.000Z","url":"/Python%E8%AF%AD%E9%9F%B3%E5%AF%B9%E8%AE%B2/2021/12/15/","tags":[["Python","/tags/Python/"]],"categories":[["undefined",""]],"content":"Python语音对讲 程序实现 server端 client端 备注 程序实现server端server.py client端client.py 备注本程序需要使用到 pyaudio 库，须提前安装 "},{"title":"线性代数-第1章-第5节-行列式按行（列）展开","date":"2021-11-21T07:38:25.000Z","url":"/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%AC%AC1%E7%AB%A0-%E7%AC%AC5%E8%8A%82-%E8%A1%8C%E5%88%97%E5%BC%8F%E6%8C%89%E8%A1%8C%EF%BC%88%E5%88%97%EF%BC%89%E5%B1%95%E5%BC%80/2021/11/21/","categories":[["undefined",""]]},{"title":"线性代数-第1章-第4节-行列式的性质","date":"2021-11-17T15:48:28.000Z","url":"/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%AC%AC1%E7%AB%A0-%E7%AC%AC4%E8%8A%82-%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E6%80%A7%E8%B4%A8/2021/11/17/","tags":[["数学","/tags/%E6%95%B0%E5%AD%A6/"],["线性代数","/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"]],"categories":[["undefined",""]],"content":"线性代数-第1章-第4节-行列式的性质 性质1 行列式和它的转置行列式相等 性质2 对换行列式的两行（列），行列式变号 推论 如果行列式有两行（列）完全相同，则此行列式等于零 性质3 行列式的某一行（列）中左右元素都乘同一数k，等于用数k乘此行列式 推论 行列式的某一行（列）的所有元素的公因子可以提到行列式记号外面 性质4 行列式中如果有两行（列）元素成比例，则此行列式等于零 性质5 若行列式的某一行（列）的元素都是两数之和，则此行列式等于两个行列式之和 性质6 把行列式的某一行（列）的各元素乘同一数后加到另一行（列）对应的元素上去，行列式不变 性质1 行列式和它的转置行列式相等$$\\begin{array}{||}a_{11} &amp; a_{12} &amp; \\dots &amp; a_{1n} \\a_{21} &amp; a_{22} &amp; \\dots &amp; a_{2n} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\a_{n1} &amp; a_{n2} &amp; \\dots &amp; a_{nn} \\\\end{array}=\\begin{array}{||}a_{11} &amp; a_{21} &amp; \\dots &amp; a_{n1} \\a_{12} &amp; a_{22} &amp; \\dots &amp; a_{n2} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\a_{1n} &amp; a_{2n} &amp; \\dots &amp; a_{nn} \\\\end{array}$$ 性质2 对换行列式的两行（列），行列式变号$$\\begin{array}{||}a_{11} &amp; a_{12} &amp; \\dots &amp; a_{1n} \\a_{21} &amp; a_{22} &amp; \\dots &amp; a_{2n} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\a_{n1} &amp; a_{n2} &amp; \\dots &amp; a_{nn} \\\\end{array}=-\\begin{array}{||}a_{21} &amp; a_{22} &amp; \\dots &amp; a_{2n} \\a_{11} &amp; a_{12} &amp; \\dots &amp; a_{1n} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\a_{n1} &amp; a_{n2} &amp; \\dots &amp; a_{nn} \\\\end{array}\\cdots\\cdots更换任意行(列)$$ 推论 如果行列式有两行（列）完全相同，则此行列式等于零$$根据性质2，将相同的两行(列)进行对换,则有\\D=-D \\implies D=0$$ 性质3 行列式的某一行（列）中左右元素都乘同一数k，等于用数k乘此行列式$$\\begin{array}{||}a_{11} &amp; a_{12} &amp; \\dots &amp; a_{1n} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ka_{i1} &amp; ka_{i2} &amp; \\dots &amp; ka_{in} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\a_{n1} &amp; a_{n2} &amp; \\dots &amp; a_{nn} \\\\end{array}=k\\begin{array}{||}a_{11} &amp; a_{12} &amp; \\dots &amp; a_{1n} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\a_{i1} &amp; a_{i2} &amp; \\dots &amp; a_{in} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\a_{n1} &amp; a_{n2} &amp; \\dots &amp; a_{nn} \\\\end{array}$$ 推论 行列式的某一行（列）的所有元素的公因子可以提到行列式记号外面性质4 行列式中如果有两行（列）元素成比例，则此行列式等于零结合性质3推论及性质2推论可得 性质5 若行列式的某一行（列）的元素都是两数之和，则此行列式等于两个行列式之和$$\\begin{array}{||}a_{11} &amp; a_{12} &amp; \\dots &amp; a_{1n} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\a_{i1}+a’{i1} &amp; a{i2}+a’{i2} &amp; \\dots &amp; a{in}+a’{in} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\a{n1} &amp; a_{n2} &amp; \\dots &amp; a_{nn} \\\\end{array}=\\begin{array}{||}a_{11} &amp; a_{12} &amp; \\dots &amp; a_{1n} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\a_{i1} &amp; a_{i2} &amp; \\dots &amp; a_{in} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\a_{n1} &amp; a_{n2} &amp; \\dots &amp; a_{nn} \\\\end{array}+\\begin{array}{||}a_{11} &amp; a_{12} &amp; \\dots &amp; a_{1n} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\a’{i1} &amp; a’{i2} &amp; \\dots &amp; a’{in} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\a{n1} &amp; a_{n2} &amp; \\dots &amp; a_{nn} \\\\end{array}$$ 性质6 把行列式的某一行（列）的各元素乘同一数后加到另一行（列）对应的元素上去，行列式不变结合性质5推论及性质2推论可得"},{"title":"线性代数-第1章-第3节-n阶行列式的定义","date":"2021-11-17T15:01:22.000Z","url":"/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%AC%AC1%E7%AB%A0-%E7%AC%AC3%E8%8A%82-n%E9%98%B6%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89/2021/11/17/","tags":[["数学","/tags/%E6%95%B0%E5%AD%A6/"],["线性代数","/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"]],"categories":[["undefined",""]],"content":"线性代数-第1章-第3节-n阶行列式的定义 推导 定义 推导研究三阶行列式$$\\begin{array}{|c|}a_{11} &amp; a_{12} &amp; a_{13} \\a_{21} &amp; a_{22} &amp; a_{23} \\a_{31} &amp; a_{32} &amp; a_{33} \\\\end{array} = a_{11}a_{22}a_{33} + a_{12}a_{23}a_{31} + a_{13}a_{21}a_{32} a_{11}a_{23}a_{32} - a_{12}a_{21}a_{33} - a_{13}a_{22}a_{31}$$可以看出： 等号右边每一项均为三个元素的乘积，三个元素均位于不同的行列中 除正负号外，右边每项均可写成 $a_{1p_{1}}a_{2p_{2}}a_{3p_{3}}$ ,这里将行标排成标准次序123，列标排成 $p_1p_2p_3$ ,它是1、2、3这三个数的某个排列 将各项列标与正负号作对比可得 带正号的列标排列为：123，231，312 带负号的列标排列为：132，213，321 通过计算得知，带正号的列标排列均为偶排列，带负号的列标排列为奇排列 三阶行列式可以写为$$\\begin{array}{|c|}a_{11} &amp; a_{12} &amp; a_{13} \\a_{21} &amp; a_{22} &amp; a_{23} \\a_{31} &amp; a_{32} &amp; a_{33} \\\\end{array}= \\sum (-1)^{t} a_{1p_{1}} a_{2p_{2}} a_{3p_{3}}$$其中t为排列 $p_1p_2p_3$ 的逆序数，$\\sum$ 表示对1，2，3 三个数的所有排列取和 由此推导出n阶行列式定义 定义$$D =\\begin{array}{|c|}a_{11} &amp; a_{12} &amp; \\dots &amp; a_{1n} \\a_{21} &amp; a_{22} &amp; \\dots &amp; a_{2n} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\a_{n1} &amp; a_{n2} &amp; \\dots &amp; a_{nn} \\\\end{array}= \\sum (-1)^{t} a_{1p_{1}} a_{2p_{2}} a_{3p_{3}}\\简记det(a_{ij})，其中数a_{ij}为行列式D的(i,j)元\\$$ 上三角形行列式 ：主对角线以下的元素全为0的行列式，叫上三角形行列式 下三角形行列式 ：主对角线以上的元素全为0的行列式，叫下三角形行列式 对角行列式 ：主对角线以外的元素全为0的行列式，叫对角行列式$$三角形行列式\\D =\\begin{array}{|c|}a_{11} &amp; &amp; &amp; 0 \\a_{21} &amp; a_{22} &amp; &amp; \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\a_{n1} &amp; a_{n2} &amp; \\dots &amp; a_{nn} \\\\end{array}= a_{11} a_{22} \\dots a_{nn}\\\\对角线行列式\\D =\\begin{array}{|c|}a_{11} &amp; &amp; &amp; 0 \\&amp; a_{22} &amp; &amp; \\&amp; &amp; \\ddots &amp; \\0 &amp; &amp; &amp; a_{nn} \\\\end{array}= a_{11} a_{22} \\dots a_{nn}\\$$"},{"title":"线性代数-第1章-第2节-全排列和对换","date":"2021-11-15T14:08:25.000Z","url":"/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%AC%AC1%E7%AB%A0-%E7%AC%AC2%E8%8A%82-%E5%85%A8%E6%8E%92%E5%88%97%E5%92%8C%E5%AF%B9%E6%8D%A2/2021/11/15/","tags":[["数学","/tags/%E6%95%B0%E5%AD%A6/"],["线性代数","/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"]],"categories":[["undefined",""]],"content":"线性代数-第1章-第2节-全排列和对换 概念 全排列 逆序数 对换 定理 定理1 推论1 概念全排列把n个不同的元素拍成一列，叫做这n个元素的 全排列 (简称 排列 ) 所有排列总数计算如下：$$P_{n} = n\\cdot(n-1)\\dots3\\cdot 2\\cdot 1 = n!$$ 逆序数 逆序数 ：对于那个不同的元素，先规定各个元素之间的一个 标准次序 (例如n个不同的自然数，可规定由小到大为标准次序)，于是在这n个元素的任意排列中，当某一对元素的先后次序与标准次序不同，就构成了1个 逆序 ,一个排列中所有的逆序的总数叫做这个排列的 逆序数 奇排列 ：逆序数为奇数的排列叫 奇排列 偶排列 ：逆序数为偶数的排列叫 偶排列 计算如下：$$t = t_{1} + t_{2} + \\dots + t_{n} = \\sum^{n}{i=1}t{i}\\t_{i}表示第i个元素构成的逆序数，若规定由小到大为标准序列，\\对与第i个元素，只需查找它前面含有n个大于此元素的个数，即t_{i} = n;$$个人理解： 标准次序：同济大学线性代数第六版中对标准次序描述为”可规定由小到大为标准次序“，即亦可规定其他次序为标准次序，但显然，由小到大这样较为直观的次序作为标准次序时，计算逆序数会变得相对简单很多。 一个排列的逆序数，奇排列，偶排列应该属于描述其对另一个排列的关系特征，而非排列本身特征，所以必须要有一个标准次序才行 对换 对换 ：在排列中，将任意两个元素对调，其余的元素不动，这种作出新排列的方法叫做对换 相邻对换 ：将相邻两个元素对换，叫相邻对换 定理定理1一个排列中的任意两个元素对换， 排列改变奇偶性 推论1奇排列对换成标准排列的对换次数为奇数， 偶排列对换成标准排列的对换次数为偶数"},{"title":"线性代数-第1章-第1节-二阶与三阶行列式","date":"2021-11-10T14:05:43.000Z","url":"/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%AC%AC1%E7%AB%A0-%E7%AC%AC1%E8%8A%82-%E4%BA%8C%E9%98%B6%E4%B8%8E%E4%B8%89%E9%98%B6%E8%A1%8C%E5%88%97%E5%BC%8F/2021/11/10/","tags":[["数学","/tags/%E6%95%B0%E5%AD%A6/"],["线性代数","/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"]],"categories":[["undefined",""]],"content":"线性代数-第1章-第1节-二阶与三阶行列式 概念 应用含义 概念$$二阶行列式\\\\begin{array}{|cc|}a_{11} &amp; a_{12}\\a_{21} &amp; a_{22}\\\\end{array}=a_{11}a_{22}-a_{12}a_{21}\\\\三阶行列式\\\\begin{array}{|cc|}a_{11} &amp; a_{12} &amp; a_{13}\\a_{21} &amp; a_{22} &amp; a_{23}\\a_{31} &amp; a_{32} &amp; a_{33}\\\\end{array}\\=a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}\\-a_{11}a_{23}a_{32}-a_{12}a_{21}a_{33}-a_{13}a_{22}a_{31}\\$$ 上面n行n列的数表，被称为 n阶行列式 数表里面的数，被称为 元素 或 元 元素的第一个下标，被称为 行标 元素的第二个下标，被称为 列标 从左上至右下的对角线称为主对角线 从右上至左下的对角线称为副对角线 行列式的结果等于所有主对角线之和减去所有副对角线之和 应用含义解二元一次方程组$$\\\\begin{cases}a_{11}x_{1} + a_{12}x_{2} = b_{1}\\a_{21}x_{1} + a_{22}x_{2} = b_{2}\\\\end{cases}\\\\\\implies\\begin{array}{}D=\\begin{array}{||}a_{11} &amp; a_{12}\\a_{21} &amp; a_{22}\\\\end{array}&amp; , &amp;D_{1}=\\begin{array}{||}b_{1} &amp; a_{12}\\b_{2} &amp; a_{22}\\\\end{array}&amp; , &amp;D_{2}=\\begin{array}{||}a_{11} &amp; b_{1}\\a_{21} &amp; b_{2}\\\\end{array}\\end{array}\\\\ \\begin{array}{}x_1 = \\frac{D_{1}}{D} =\\frac{\\begin{array}{||}b_{1} &amp; a_{12}\\b_{2} &amp; a_{22}\\\\end{array}}{\\begin{array}{||}a_{11} &amp; a_{12}\\a_{21} &amp; a_{22}\\\\end{array}}&amp; , &amp;x_2 = \\frac{D_{2}}{D} =\\frac{\\begin{array}{||}a_{11} &amp; b_{1}\\a_{21} &amp; b_{2}\\\\end{array}}{\\begin{array}{||}a_{11} &amp; a_{12}\\a_{21} &amp; a_{22}\\\\end{array}}\\end{array}$$解三元一次方程组$$\\\\begin{cases}a_{11}x_{1} + a_{12}x_{2} + a_{13}x_{3} = b_{1}\\a_{21}x_{1} + a_{22}x_{2} + a_{23}x_{3} = b_{2}\\a_{31}x_{1} + a_{32}x_{2} + a_{33}x_{3} = b_{3}\\\\end{cases}\\\\\\implies\\begin{array}{}D=\\begin{array}{||}a_{11} &amp; a_{12} &amp; a_{13}\\a_{21} &amp; a_{22} &amp; a_{23}\\a_{31} &amp; a_{32} &amp; a_{33}\\\\end{array}&amp; , &amp;D_{1}=\\begin{array}{||}b_{1} &amp; a_{12} &amp; a_{13}\\b_{2} &amp; a_{22} &amp; a_{23}\\b_{3} &amp; a_{32} &amp; a_{33}\\\\end{array}&amp; , &amp;D_{2}=\\begin{array}{||}a_{11} &amp; b_{1} &amp; a_{13}\\a_{21} &amp; b_{2} &amp; a_{23}\\a_{31} &amp; b_{3} &amp; a_{33}\\\\end{array}&amp; , &amp;D_{3}=\\begin{array}{||}a_{11} &amp; a_{12} &amp; b_{1}\\a_{21} &amp; a_{22} &amp; b_{2}\\a_{31} &amp; a_{32} &amp; b_{3}\\\\end{array}\\end{array}\\\\\\begin{array}{}x_1 = \\frac{D_{1}}{D} =\\frac{\\begin{array}{||}b_{1} &amp; a_{12} &amp; a_{13}\\b_{2} &amp; a_{22} &amp; a_{23}\\b_{3} &amp; a_{32} &amp; a_{33}\\\\end{array}}{\\begin{array}{||}a_{11} &amp; a_{12} &amp; a_{13}\\a_{21} &amp; a_{22} &amp; a_{23}\\a_{31} &amp; a_{32} &amp; a_{33}\\\\end{array}}&amp; , &amp;x_2 = \\frac{D_{2}}{D} =\\frac{\\begin{array}{||}a_{11} &amp; b_{1} &amp; a_{13}\\a_{21} &amp; b_{2} &amp; a_{23}\\a_{31} &amp; b_{3} &amp; a_{33}\\\\end{array}}{\\begin{array}{||}a_{11} &amp; a_{12} &amp; a_{13}\\a_{21} &amp; a_{22} &amp; a_{23}\\a_{31} &amp; a_{32} &amp; a_{33}\\\\end{array}}&amp; , &amp;x_3 = \\frac{D_{3}}{D} =\\frac{\\begin{array}{||}a_{11} &amp; a_{12} &amp; b_{1}\\a_{21} &amp; a_{22} &amp; b_{2}\\a_{31} &amp; a_{32} &amp; b_{3}\\\\end{array}}{\\begin{array}{||}a_{11} &amp; a_{12} &amp; a_{13}\\a_{21} &amp; a_{22} &amp; a_{23}\\a_{31} &amp; a_{32} &amp; a_{33}\\\\end{array}}\\end{array}$$"},{"title":"卡尔曼滤波（数据融合）","date":"2021-10-29T13:34:54.000Z","url":"/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%EF%BC%88%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88%EF%BC%89/2021/10/29/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["undefined",""]],"content":"卡尔曼滤波（数据融合） 概述 核心公式 推导过程 举例子 概述多个独立的测量工具，对同一物体进行测量，其测量结果符合正态分布，通过已知的测量结果估算出最接近实际值的结果数据 核心公式 推导过程 举例子 结果如图所示 两个测量系统的数据分布分别为绿蓝曲线，通过数据融合后得到红色曲线，其对应的数据标准差更小，应该更准确 "},{"title":"Typora编辑公式","date":"2021-10-01T14:25:37.000Z","url":"/Markdown%E7%BC%96%E8%BE%91%E5%85%AC%E5%BC%8F/2021/10/01/","tags":[["Typora","/tags/Typora/"]],"categories":[["undefined",""]],"content":"Typora编辑公式 Typora偏好设置 公式书写 常用语法 分行 上下标 分数 开方 矢量 积分 极限 累加累乘 行标 希腊字母 特殊符号 等号对齐 矩阵 更多参考： Typora偏好设置 公式书写markdown中的公式，都得使用一个或两个$来括起来 单$符引住的是行内公式 双$符引住的是行间公式$$\\begin{aligned}1&amp;=2\\12&amp;=5000\\end{aligned}$$ 常用语法分行分行使用 \\\\ ，例如：$12\\\\24$ 上下标上标使用 ^ ，例如：$x^2$ 下标使用 _ ，例如：$x_2$ 分数分数使用 \\frac ，例如：$\\frac&#123;x&#125;&#123;x+1&#125;$ 开方开方使用 \\sqrt ，例如：$sqrt[n]&#123;3&#125;$ 矢量矢量使用 \\vec ，例如：$\\vec&#123;a&#125;$ 积分积分使用 \\int ，例如：$\\int_0^1x^2dx$ 极限极限使用 \\lim ，例如：$\\lim_&#123;0 \\to \\infty&#125;$ 累加累乘累加使用 \\sum ，例如：$\\sum_&#123;i=1&#125;^ni$ 累乘使用 \\prod ，例如：$\\prod_&#123;i=1&#125;^ni$ 行标行标在公式末尾使用 \\tag ，例如：$x=1 \\tag1$ 希腊字母 特殊符号 等号对齐起始标记 \\begin&#123;aligned&#125; 结束标记 \\end&#123;aligned&#125; 在每个等号前添加&amp;符号 举例： 显示为： 矩阵基本语法起始标记 \\begin&#123;matrix&#125; 结束标记 \\end&#123;matrix&#125; 每一行末尾标记 \\\\ ，行间元素之间以&amp;分隔 举例： 显示为： 矩阵边框在起始、结束标记处用下列词替换 matrix pmatrix ：小括号边框 bmatrix ：中括号边框 Bmatrix ：大括号边框 vmatrix ：单竖线边框 Vmatrix ：双竖线边框 省略元素横省略号： \\cdots 竖省略号： \\vdots 斜省略号： \\ddots 阵列需要array环境：起始、结束处以 &#123;array&#125; 声明 对齐方式：在{array}后以 &#123;&#125; 逐列统一声明 左对齐使用 l ，居中使用 c ，右对齐使用 r 在声明对齐方式时插入 | 建立竖直线 \\hline 建立水平线 方程组需要cases环境：起始、结束处以{cases}声明 举例： 显示为： "},{"title":"卡尔曼滤波器","date":"2021-10-01T09:25:37.000Z","url":"/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/2021/10/01/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["undefined",""]],"content":"卡尔曼滤波器 概述 计算公式 计算步骤 示例 概述卡尔曼滤波器属于一种最优化递归数字处理的算法。主要用于解决系统的不确定性： 现实中不存在完美的数学模型 系统的扰动不可控，且很难建模 测量传感器存在误差 计算公式第k次估计值： 其中，z_k为第k次的测量值 当k值较大时，1/k较小，第k次估计值接近接近于上一次估计值，测量的结果显得不那么重要 当k值较小时，1/k较大，第k次估计值受上一次测量值影响较大 将1/k使用一个系数K_k表示，即： 公式含义为 其中K_k系数被称为卡尔曼增益或卡尔曼因数 引入参数估计误差e_EST、测量误差e_MEA 在k时刻： 当估计误差e_EST远大于测量误差e_MEA，卡尔曼增益系数K_k趋近于1，第k次估计值接近接近于测量值 当估计误差e_EST远小于测量误差e_MEA，卡尔曼增益系数K_k趋近于0，第k次估计值接近接近于上一次估计值 计算步骤 计算卡尔曼增益系数 计算第k次估计值 更新估计误差 示例测量一个长度50cm的物体，尺子的误差3cm，首次的估计值为40cm，测量误差5cm，可得： 通过测量一系列数据，估计值会快速趋近于真实值，达到测量的目的"},{"title":"PID算法","date":"2021-09-24T13:10:07.000Z","url":"/PID%E7%AE%97%E6%B3%95/2021/09/24/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["undefined",""]],"content":"PID算法 PID简介 框图 公式 C语言代码实现 PID简介在闭环控制系统中，根据实际输出与设定输出误差进行反馈调节输入的控制器。PID是比例 (Proportion) 积分，(Integral) 微分，(Differential coefficient) 的缩写。 框图 图中： tar(t) ：控制对象的目标输出量 out(t) ：控制对象的实际输出量 e(t) ：控制对象的目标输出量与实际输出量的误差，e(t) = tar(t) - out(t) ctrl(t) ：对控制对象的输出的控制值 公式连续PID公式 离散PID公式 其中： T为采样时间，此公式称为位置式PID公式 将位置式PID公式进行转换，即可得到增量式PID公式 C语言代码实现"},{"title":"Pelco协议解析","date":"2021-09-21T08:29:38.000Z","url":"/Pelco%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/2021/09/21/","tags":[["协议解析","/tags/%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/"]],"categories":[["undefined",""]],"content":"Pelco协议解析 Pelco协议 PelcoD协议 通讯参数 命令格式 常用命令列表 PelcoP协议 通讯参数 命令格式 常用命令列表 Pelco协议Pelco协议为RS422或RS485通讯，分为PelcoD与PelcoP两种协议 一般用于云台、摄像机控制通讯 PelcoD协议通讯参数波特率：2400bps 起始位：1位 数据位：8位 校验位：无 停止位：1位 命令格式 byte1 byte2 byte3 byte4 byte5 byte6 byte7 帧头 地址码 命令字1 命令字2 数据1 数据2 校验码 协议中数据均为十六进制数 帧头固定不变，为0xFF 地址码为设备地址，范围0x00-0xFF 指令码表示不同的动作 数据1、数据2一般便是水平与垂直方向的速度 校验码 = MOD((byte2+byte3+byte4+byte5+byte6+byte7)/0x100) 常用命令列表以地址0x01为例 指令 数据 上 FF 01 00 08 00 FF 08 下 FF 01 00 10 00 FF 10 左 FF 01 00 04 FF 00 04 右 FF 01 00 02 FF 00 02 变倍短 FF 01 00 20 00 00 21 变倍长 FF 01 00 40 00 00 41 聚焦近 FF 01 00 80 00 00 81 聚焦远 FF 01 01 00 00 00 02 光圈小 FF 01 02 00 00 00 03 光圈大 FF 01 04 00 00 00 05 灯光关 FF 01 00 0B 00 01 0D 灯光开 FF 01 00 09 00 01 0B 停止 FF 01 00 00 00 00 01 PelcoP协议通讯参数波特率：4800bps 起始位：1位 数据位：8位 校验位：无 停止位：1位 命令格式 byte1 byte2 byte3 byte4 byte5 byte6 byte7 byte8 帧头 地址码 命令字1/数据1 命令字2/数据2 数据3 数据4 帧尾 校验码 协议中数据均为十六进制数 帧头固定不变，为0xA0 地址码为设备地址，范围0x00-0xFF 指令码表示不同的动作 数据1、数据2一般便是水平与垂直方向的速度 帧尾固定不变，为0xAF 校验码 = byte2 ^ byte3 ^ byte4 ^ byte5 ^ byte6 常用命令列表以地址0x01为例 指令 数据 上 A0 01 00 08 00 30 AF 39 下 A0 01 00 10 00 30 AF 21 左 A0 01 00 04 10 00 AF 15 右 A0 01 00 02 10 00 AF 13 变倍短 A0 01 00 40 00 00 AF 41 变倍长 A0 01 00 20 00 00 AF 21 聚焦近 A0 01 02 00 00 00 AF 81 聚焦远 A0 01 01 00 00 00 AF 00 光圈小 A0 01 08 00 00 00 AF 09 光圈大 A0 01 04 00 00 00 AF 05 灯光关 不支持 灯光开 不支持 停止 A0 01 00 00 00 00 AF 01 "},{"title":"开关电源电感选择","date":"2021-09-21T04:40:15.000Z","url":"/%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90%E7%94%B5%E6%84%9F%E9%80%89%E6%8B%A9/2021/09/21/","tags":[["硬件","/tags/%E7%A1%AC%E4%BB%B6/"],["开关电源","/tags/%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90/"]],"categories":[["undefined",""]],"content":"开关电源电感选择 理论 举例子 结论 理论电感为磁性元件，一般工作在线性区，即不应该出现磁饱和现象 当电感中有电流流过时，电感储存的能力为 一个开关周期中，电感电流变化值(纹波电流)与电感电压值的关系为 由此可知，纹波电流大小与电感值有关 纹波电流一般设定为最大输出电流的10%-30%，因此对降压型电源来说，流过电感的电流峰值比电源输出电流大5%-15% 举例子假设如图，开关频率为150kHz，输入电压范围24V±20%，输出电压5V，输出电流为1A，最大纹波电流100mA，D1正向压降0.6V 输入电压最大为 开关占空比为 开关管导通时，电感电压值为 开关管断开时，电感电压值为 时间变化值为 需要电感的值为 所以，选择电感330μH合适 结论一般地，电感变大，输出纹波会相应变小，但电源的动态响应也会相应变差 提高开关频率可以选择更小的电感值，从而使电感的尺寸更小，便于电子产品的小型化，但需要注意高频的谐波干扰"},{"title":"开关电源类型","date":"2021-09-21T04:35:13.000Z","url":"/%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90%E7%B1%BB%E5%9E%8B/2021/09/21/","tags":[["硬件","/tags/%E7%A1%AC%E4%BB%B6/"],["开关电源","/tags/%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90/"]],"categories":[["undefined",""]],"content":"开关电源类型 降压式(BUCK) 特点 升压式(BOOST) 特点 反转式(BUCK-BOOST) 特点 单端反激式 特点 单端正激式 特点 自激式 特点 推挽式 特点 降压式(BUCK) 特点输出电压小于输入电压 升压式(BOOST) 特点输出电压大于输入电压 反转式(BUCK-BOOST) 特点输出电压不受输入电压幅值限制，但是极性相反 单端反激式 特点成本低，纹波大，适用于相对固定负载 单端正激式 特点功率范围大(50-200W)，变压器复杂，体积大，实际应用较少 自激式 特点省去控制电路，大小功率均可，目前应用广泛 推挽式 特点功率较大(100-500W)，需要开关管耐压值大于2倍电路峰值电压"},{"title":"VM虚拟机与主机之间无法复制粘贴问题","date":"2021-09-20T08:07:53.000Z","url":"/VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E6%97%A0%E6%B3%95%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E9%97%AE%E9%A2%98/2021/09/20/","tags":[["VM","/tags/VM/"]],"categories":[["undefined",""]],"content":"VM虚拟机与主机之间无法复制粘贴问题 卸载open-vm-tools 重新安装vmware tools 安装open-vm-tools-desktop 先确认虚拟机是否设置了客户机隔离，否则可能由于异常导致vmware tools失效 卸载open-vm-tools 重新安装vmware tools虚拟光驱文件解压出来执行sudo ./vmware-install.pl 安装open-vm-tools-desktop 重启即可"},{"title":"WIN10LTSC激活","date":"2021-09-20T07:59:22.000Z","url":"/WIN10LTSC%E6%BF%80%E6%B4%BB/2021/09/20/","tags":[["WIN10","/tags/WIN10/"]],"categories":[["undefined",""]],"content":"WIN10LTSC激活 CMD打开控制台 完成"},{"title":"树莓派设置共享文件夹","date":"2021-09-19T15:01:31.000Z","url":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%AE%BE%E7%BD%AE%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/2021/09/19/","tags":[["Linux","/tags/Linux/"],["树莓派","/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"],["samba","/tags/samba/"]],"categories":[["undefined",""]],"content":"树莓派设置共享文件夹 安装samba 修改配置文件 重启samba服务 添加共享用户 添加网络硬盘 安装samba 修改配置文件 在 smb.conf 文件末尾添加 重启samba服务 添加共享用户 添加网络硬盘在window主机上，此电脑，右击网络，映射网络驱动器 完成"},{"title":"树莓派自动挂载硬盘","date":"2021-09-19T15:00:18.000Z","url":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/2021/09/19/","tags":[["Linux","/tags/Linux/"],["树莓派","/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"]],"categories":[["undefined",""]],"content":"树莓派自动挂载硬盘 创建挂载路径 查看接入的硬盘 挂载 查看 安装NTFS格式可读写软件 加载内核模块 设置开机自动挂载 注意：树莓派USB口供电较弱，移动硬盘需要额外供电 创建挂载路径新建一个路径用于挂载硬盘 查看接入的硬盘 挂载 查看 安装NTFS格式可读写软件此时，由于硬盘是NTFS格式，树莓派不支持写入，需要安装NTFS格式可读写软件 加载内核模块 fuse为用户空间文件系统内核模块，是Linux 中用于挂载某些网络空间到本地文件系统的模块 设置开机自动挂载 最后一行添加 保存，退出即可"},{"title":"TensorFlow基础知识","date":"2021-09-11T13:10:17.000Z","url":"/TensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2021/09/11/","tags":[["Tensorflow","/tags/Tensorflow/"]],"categories":[["undefined",""]],"content":"TensorFlow基础知识 数据类型 创建一个Tensor Numpy数据转Tensor数据 创建元素相同的张量 创建随机张量 常用函数 强制类型转换 计算张量元素最小值 计算张量元素最大值 数据类型 创建一个Tensor 例子 输出结果 Numpy数据转Tensor数据 例子 输出结果 创建元素相同的张量 例子 输出结果 创建随机张量 例子 输出结果 常用函数强制类型转换 计算张量元素最小值 计算张量元素最大值"},{"title":"Tensorflow2.1开发环境搭建","date":"2021-09-10T14:02:41.000Z","url":"/Tensorflow2-1%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/2021/09/10/","tags":[["Tensorflow","/tags/Tensorflow/"]],"categories":[["undefined",""]],"content":"Tensorflow2.1开发环境搭建 准备 安装Anaconda3 下载地址 安装 搭建Tensorflow2.1环境 创建TF2.1环境 激活TF2.1环境 安装显卡依赖 安装Tensorflow2.1 Tensorflow2.1环境验证 安装PyCharm 下载地址 安装 测试demo 新建工程 选择环境 创建工程 编辑demo测试代码 运行 准备anaconda3 安装Anaconda3下载地址下载2019-10 window 64bit版本  安装双击运行安装包，按照界面指引安装 注意：在Advanced Options页需要勾选 Add Anaconda to the systemPath environment 搭建Tensorflow2.1环境创建TF2.1环境开始菜单中打开 Anaconda Prompt(Anaconda) 在打开的控制台中输入 创建python3.7版本的TF2.1环境，安装提示直接 Y 回车 激活TF2.1环境 激活刚刚创建的TF2.1环境 安装显卡依赖如果电脑安装了英伟达的显卡，可以安装GPU的加速 安装提示直接 Y 回车 如果报错，可能是没有显卡或显卡不支持，可以直接跳过 安装Tensorflow2.1 Tensorflow2.1环境验证进入python3.7环境 输入验证代码 如下图中，结果出现tensorflow的版本号为2.1.0，即Tensorflow2.1环境安装完成 安装PyCharm下载地址下载社区版  安装双击运行安装包，按照界面指引安装 注意：在Installation Options页需要勾选 Add &quot;bin&quot; folder to the PATH 安装完成，需要重启电脑 测试demo新建工程打开PyCharm，新建工程 选择环境 选择刚刚搭建的环境 创建工程 编辑demo测试代码 运行运行结果如下图所示 运行框输出tf.Tensor的信息即可认为整个Tensorflow2.1开发环境搭建搭建完成"},{"title":"ROS服务提供与调用（二）","date":"2021-09-06T14:40:32.000Z","url":"/ROS%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E4%B8%8E%E8%B0%83%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2021/09/06/","tags":[["Linux","/tags/Linux/"],["ROS","/tags/ROS/"]],"categories":[["undefined",""]],"content":"ROS服务提供与调用（二） 创建自己的服务数据 创建srv文件 修改package.xml文件 修改CMakeLixt.txt文件 验证自己的服务数据 使用自己的服务数据 创建程序 编译 执行 第一个终端 第二个终端 第三个终端 创建自己的服务数据创建srv文件创建 ~/catkin_ws/src/pub_sub_test/srv 路径并创建 MyService.srv 文件 MyService.srv 知识点： 文件名必须以 .srv 结尾 srv请求与响应数据通过 --- 分隔，前面为请求，后面为响应 变量类型和变量名之间以空格隔开，不能使用tab 修改package.xml文件将生成服务数据需要的依赖环境注释去除 修改CMakeLixt.txt文件 验证自己的服务数据 使用自己的服务数据创建程序 ros_server2.cpp ros_client2.cpp 注意： 创建服务数据文件时是 .srv 文件，使用时include是 .h 文件，原因是ros在编译过程中会生成相应的 .h 文件以供调用。 编译编辑 CMakeLists.txt 文件 CMakeLists.txt中添加 编译 执行第一个终端 第二个终端 打开服务端 第三个终端 打开客户端 "},{"title":"ROS服务提供与调用（一）","date":"2021-09-05T12:15:17.000Z","url":"/ROS%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E4%B8%8E%E8%B0%83%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/2021/09/05/","tags":[["Linux","/tags/Linux/"],["ROS","/tags/ROS/"]],"categories":[["undefined",""]],"content":"ROS服务提供与调用（一） 创建程序 编译 执行 第一个终端 第二个终端 第三个终端 创建程序 ros_server.cpp ros_client.cpp 注意： server端程序是会一直在死循环里面的，当 ros::spin() 或 ros::spinOnce() 被调用的时候，才会去检测回调函数队列中。 ros::spinOnce() 被调用时，会调用回调函数队列中的第一个callback函数并将其清出队列，然后退出。 ros::spinOnce() 每次调用只能清除队列中的一个callback函数 ros::spin() 相当于死循环，不会返回，回调函数队列中有callback函数就调用并将其清出队列，没有就阻塞，不占用CPU资源。 编译编辑 CMakeLists.txt 文件 CMakeLists.txt中添加 编译 执行第一个终端 第二个终端 打开服务端 第三个终端 打开客户端 "},{"title":"Ubuntu18修改网卡Mac地址","date":"2021-09-05T05:45:27.000Z","url":"/Ubuntu18%E4%BF%AE%E6%94%B9%E7%BD%91%E5%8D%A1Mac%E5%9C%B0%E5%9D%80/2021/09/05/","tags":[["Linux","/tags/Linux/"],["Ubuntu","/tags/Ubuntu/"]],"categories":[["undefined",""]],"content":"Ubuntu18修改网卡Mac地址 临时修改 永久修改 方法一 方法二 临时修改控制台输入 永久修改方法一将临时修改指令设置开机自启 方法二编辑 /etc/network/interfaces 文件，在 iface eth0 inet static 后面添加： 重启网卡"},{"title":"Ubuntu18使用Aircrack-ng破解WiFi","date":"2021-08-31T13:48:02.000Z","url":"/Ubuntu18%E4%BD%BF%E7%94%A8Aircrack-ng%E7%A0%B4%E8%A7%A3WiFi/2021/08/31/","tags":[["Linux","/tags/Linux/"],["Ubuntu","/tags/Ubuntu/"],["Aircrack-ng","/tags/Aircrack-ng/"],["Wifi破解","/tags/Wifi%E7%A0%B4%E8%A7%A3/"]],"categories":[["undefined",""]],"content":"Ubuntu18使用Aircrack-ng破解WiFi 原理 步骤 安装Aircrack-ng 监控无线网卡 搜索WiFi 抓包 触发重连 获取到握手包 停止监控无线网卡 破解密码 密码字典生成 下载安装crunch crunch生成字典 扩展 请自觉遵守《中华人民共和国网络安全法》及其他法律法规 原理查看连接在目标wifi下的客户端，对其发送断网信号，使其对目标AP发送重连握手包，抓到握手包后，使用密码字典暴力破解 步骤安装Aircrack-ng 监控无线网卡 wlan_name 填写需要使用的无线网卡名称 示例为： 注意：经过监听无线网卡后，原有无线网卡wlxc83a35b0433e 将被禁用，取而代之的是 wlan0mon ，（运行监听命令后控制台会输出名称） 搜索WiFi wlan_name 填写被监控中的无线网卡名称 示例为： 获取到目标WiFi的Mac地址后，可以 Ctrl+C 停止 抓包打开一个新的控制台 Channel 填写需要破解的WiFi的Channel信息 WiFi_Mac 填写需要破解的WiFi的Mac地址 file_name 填写生成的抓包文件名称 wlan_name 填写被监控中的无线网卡名称 示例为 此处正在抓包，不要关闭程序 触发重连打开一个新的控制台 WiFi_Mac 填写 需要破解的WiFi的Mac地址 file_name 填写生成的抓包文件名称，一般程序会自动在后面加数字 wlan_name 填写被监控中的无线网卡名称 发送指令后，客户端掉线会自动发送包含密码信息的重连包 示例为 获取到握手包在抓包的控制台右上角出现 WAP handshake 字样，即为获取到握手包 停止监控无线网卡无线网卡在不需要监控的情况下应该进行停止监控操作 wlan_name 填写被监控中的无线网卡名称 示例为 破解密码 file_name1 填写字典文件名称，一般会是 .txt 文件 file_name2 填写获取到握手包的抓包文件名称，一般会是 .cap 文件 这时，只有安静的等待即可。。。 示例为 WiFi加密方式为WEP加密方式的密码可以直接跑出来，WPA/WPA2加密方式的密码没跑出来(╥_╥) 密码字典生成下载安装crunch crunch生成字典生成8位数字密码字典 扩展"},{"title":"身份证号码算法","date":"2021-08-22T13:59:11.000Z","url":"/%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E7%A0%81%E7%AE%97%E6%B3%95/2021/08/22/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["undefined",""]],"content":"身份证号码算法 长度 编码 地址码 出生日期码 顺序码 校验码 举例 身份证号码为国家管理公民的方法手段，请遵纪守法，切勿乱用，天网恢恢，疏而不漏！！！ 参考： 国家标准(GB 11643) 国家标准(GB/T 2260) 国家标准(GB/T 7408) 长度目前，我国使用的第二代居民身份证为18位长度 编码6位数字地址码 + 8位出生日期码 + 3位顺序码 + 1位校验码 地址码根据《中华人民共和国行政区划代码》国家标准(GB/T 2260)规定编码公民的常住户口所在县(市、旗、区)行政区划代码 出生日期码根据《数据元和交换格式 信息交换 日期和时间表示法》国家标准(GB/T 7408)规定编码公民的出生年、月、日，代码之间不用分隔符 顺序码对同一地址码区域内同一天出生的公民编制的顺序号，男性为奇数，女性为偶数 校验码对前17位数字进行校验计算，最终生成一个校验码 校验方法： 十七位数字加权求和 ai ：身份证上的第i位数字 wi ：身份证上的第i位数字的加权因子，分别为7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2 计算模 查找模对应校验码 y 0 1 2 3 4 5 6 7 8 9 10 校验码 1 0 X 9 8 7 6 5 4 3 2 举例北京东城区2000年1月1日第999号的男性公民 地址码 出生日期码 顺序码 校验码 110101 20000101 999 8 声明： 此身份证号码为理解算法举例子所用，不确定是否真实存在此人，如有不当，请联系删除"},{"title":"Linux下通过路径查找串口号","date":"2021-08-20T21:38:10.000Z","url":"/Linux%E4%B8%8B%E9%80%9A%E8%BF%87%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE%E4%B8%B2%E5%8F%A3%E5%8F%B7/2021/08/21/","tags":[["Linux","/tags/Linux/"],["硬件","/tags/%E7%A1%AC%E4%BB%B6/"],["串口","/tags/%E4%B8%B2%E5%8F%A3/"]],"categories":[["undefined",""]],"content":"Linux下通过路径查找串口号 背景 方案 查看硬件接入信息 脚本 背景Linux系统下，每接入一个串口，其串口号一般会由0开始递增，但由于多个串口设备同时接入、串口程序资源未释放、其他端口号占用等问题，导致串口设备的串口号无法固定 方案通过记录串口设备的硬件接入路径，查找串口进行路径对比，返回串口号 查看硬件接入信息 此处 DEVPATH 为硬件路径信息 脚本可编辑脚本对串口设备进行路径对比，返回该路径下的串口号 FindttyUSBxByPath.sh 添加执行权限后使用 此处 path 参数可以填写路径中的唯一的一部分即可，如样例中ttyUSB0出现前最后面数字路径即可 "},{"title":"微信小程序开发环境搭建","date":"2021-08-19T13:42:25.000Z","url":"/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/2021/08/19/","tags":[["微信小程序","/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"categories":[["undefined",""]],"content":"微信小程序开发环境搭建 参考："},{"title":"Qt生成exe并运行","date":"2021-08-18T13:22:43.000Z","url":"/Qt%E7%94%9F%E6%88%90exe%E5%B9%B6%E8%BF%90%E8%A1%8C/2021/08/18/","tags":[["Qt","/tags/Qt/"]],"categories":[["undefined",""]],"content":"Qt生成exe并运行 目的 工具 具体步骤 Debug改为Release 构建和运行 新建文件夹存放执行文件 打开MinGW控制台 切换到放执行文件的文件夹 复制相关库 打包 目的在windows下，Qt调试完成后，希望生成一个exe文件可以在别的电脑上也能运行 工具windows下qt5.10.0 具体步骤Debug改为Release 构建和运行点击运行后，会自动构建且运行，在构建目录生成exe文件 此时，直接双击exe文件是运行不了的 新建文件夹存放执行文件 打开MinGW控制台 切换到放执行文件的文件夹 复制相关库输入 此命令将会把程序所需的相关库文件全部复制到当前文件夹下 打包此时，将整个文件夹压缩打包发送到另一台电脑解压即可运行"},{"title":"Ubuntu18默认Python版本切换","date":"2021-08-17T13:25:25.000Z","url":"/Ubuntu18%E9%BB%98%E8%AE%A4Python%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/2021/08/17/","tags":[["Linux","/tags/Linux/"],["Python","/tags/Python/"],["Ubuntu","/tags/Ubuntu/"]],"categories":[["undefined",""]],"content":"Ubuntu18默认Python版本切换 添加手动模式列表 查看Python版本候选列表 设置Python默认版本 Ubuntu18默认自带有python2和python3的环境，可以通过以下指令查看 添加手动模式列表 命令行最后一个数字为优先级，默认自动模式情况下数字大的优先级高 查看Python版本候选列表 设置Python默认版本 直接输入编号按回车即可 "},{"title":"Hexo新建文章标题带空格","date":"2021-08-17T13:19:39.000Z","url":"/Hexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98%E5%B8%A6%E7%A9%BA%E6%A0%BC/2021/08/17/","tags":[["Hexo","/tags/Hexo/"]],"categories":[["undefined",""]],"content":"Hexo新建文章标题带空格 "},{"title":"Hexo部署git失败：The requested URL returned error: 403","date":"2021-08-17T13:04:41.000Z","url":"/Hexo%E9%83%A8%E7%BD%B2git%E5%A4%B1%E8%B4%A5%EF%BC%9AThe-requested-URL-returned-error-403/2021/08/17/","tags":[["Hexo","/tags/Hexo/"]],"categories":[["undefined",""]],"content":"Hexo部署git失败：The requested URL returned error: 403 具体操作 当使用 hexo d 时出现以下代码 可能时电脑的凭证管理异常，删除该凭证，重新登陆github即可 具体操作打开凭证管理器 删除上图中框选的github凭证 重新使用 hexo d 部署将会出现登录验证，输入登录信息即可"},{"title":"ROS发布消息（Python版）","date":"2021-08-16T14:48:42.000Z","url":"/ROS%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF%EF%BC%88Python%E7%89%88%EF%BC%89/2021/08/16/","tags":[["Linux","/tags/Linux/"],["ROS","/tags/ROS/"],["Python","/tags/Python/"]],"categories":[["undefined",""]],"content":"ROS发布消息（Python版） 创建程序 执行 第一个终端 第二个终端 第三个终端 创建程序在原有的功能包pub_sub_test中添加scripts文件夹，用于放置python程序源码，以区分c++程序 pub_velocity.py 创建程序完成后，需要对其添加可执行权限 程序主要发布了一个速度信息，可以控制小海龟移动 执行第一个终端 第二个终端 打开小海龟节点，用于观察发布的消息被使用的效果 第三个终端 Python是一种解释语言，通过解释器解释即可，无需类似C++编译的过程 "},{"title":"ROS创建自己的消息类型","date":"2021-08-12T13:00:46.000Z","url":"/ROS%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B/2021/08/12/","tags":[["Linux","/tags/Linux/"],["ROS","/tags/ROS/"]],"categories":[["undefined",""]],"content":"ROS创建自己的消息类型 创建msg文件 修改CMakeLixt.txt文件 修改package.xml文件 创建程序 运行 第一个终端 第二个终端 第三个终端 ROS提供了不少的消息类型以供使用，但如果我们还是想要使用其他的消息类型，则需要自己创建 创建msg文件首先创建一个msg文件夹存放 .msg 文件 MyMessage.msg .msg 文件格式为 成员类型 自定义成员名字 修改CMakeLixt.txt文件添加依赖包和消息文件 修改package.xml文件将生成消息需要的依赖环境注释去除 创建程序 pub_mymessage.cpp 最后，把这个文件添加到CMakeLists.txt编译。 运行第一个终端 第二个终端 第三个终端 这里，通过rostopic可以直接观察到发布的自定义消息，如需订阅，类似。 "},{"title":"ROS使用tf追踪不同坐标系","date":"2021-08-08T10:23:15.000Z","url":"/ROS%E4%BD%BF%E7%94%A8tf%E8%BF%BD%E8%B8%AA%E4%B8%8D%E5%90%8C%E5%9D%90%E6%A0%87%E7%B3%BB/2021/08/08/","tags":[["Linux","/tags/Linux/"],["ROS","/tags/ROS/"]],"categories":[["undefined",""]],"content":"ROS使用tf追踪不同坐标系 基础例子 编程 运行 多个坐标系追踪 运行 更多参考： 机器人上会存在不同的坐标系，那么坐标系之间的关系转换，可以通过tf实现 基础例子编程 turtle_tf2_broadcaster.cpp 程序的作用是通过订阅经典案例小乌龟发布的位置转换成为坐标系通过tf2发布并在rviz中显示出来 知识点： 本程序package包需要依赖 geometry_msgs 、 visualization_msgs 、 tf ，添加方式参考 **ROS发布订阅消息（一）**中创建一个package包步骤后半部分 头文件 &lt;tf2/LinearMath/Quaternion.h&gt; t提供了 tf::Quaternion 的类，与 geometry::Quaternion 类似，坐标轴的位姿也是通过四元数定义的。q.setRPY(0, 0, msg-&gt;theta)，这个函数完成了从roll pitch yaw到四元数的转换功能，通过设定roll pitch yaw来设定四元数的具体数据 头文件 &lt;tf2_ros/transform_broadcaster.h&gt; 提供了 tf2_ros::TransformBroadcaster 发布坐标转换的类，可以通过 br.sendTransform(transformStamped) 将坐标转换的对象发布出去 头文件 #include &lt;turtlesim/Pose.h&gt; 是小乌龟案例中使用的，包含了Pose消息类型 程序中 transformStamped.header.frame_id = &quot;world&quot; 为父坐标系，此处参数应与rviz中世界坐标系参数一致， transformStamped.child_frame_id = turtle_name 为子坐标系，参数为子坐标系名字，rviz中tf接收到消息后会自动在左侧tf中显示相关内容 主函数中， ros::NodeHandle private_node(&quot;~&quot;) 通过 ~ 参数读取 .launch 文件的局部参数 把这个文件添加到CMakeLists.txt编译。 新建一个 .launch 文件 test_tf.launch 知识点： 在 &lt;node&gt;...&lt;/node&gt; 内部定义的参数称为局部参数，必须定义一个私有 nodehandle ，即 ros::NodeHandle abc(&quot;~&quot;) 并使用代码 abc.getParam(...) 才能读取 运行第一个终端 此时出现一个小乌龟窗口，并且通过方向按键可以控制其移动 第二个终端 这个可以查看两个坐标系 /world 与 /turtle1 之间的关系 第三个终端 打开rviz后，点击界面左下方的 add ,出现添加可视化物体的选项框 选择 TF ，点击 OK ，界面左边将会增加一个TF坐标转换，将世界坐标系名称改为 world 此时，rviz出现两个坐标，且当控制小乌龟移动的时候，rviz中的turtle1坐标系跟着相应移动 多个坐标系追踪如果两个坐标系相对运动，那么在父坐标系的基础上发布子坐标，操作与前面一样 如果两个坐标系相对静止，那么可以直接在 .launch 文件中定义即可，无需额外编写程序 test_tf_2.launch 其实，是使用了现成的名叫 tf2_ros 这个pakcage里名叫 static_transform_publisher 这个可执行文件，节点名我们命名为 link1_broadcaster ，args即我们要传入的transform了，前三个数字是transform的xyz平移，后四个是四元数x,y,z,w 运行第一个终端 此时出现一个小乌龟窗口，并且通过方向按键可以控制其移动 第二个终端 打开rviz后，按照之前的配置添加TF，修改世界坐标名称，即可看到三个坐标系之间关系，且移动小乌龟，坐标系之间的存在变换 "},{"title":"ROS使用rviz","date":"2021-08-05T13:40:23.000Z","url":"/ROS%E4%BD%BF%E7%94%A8rviz/2021/08/05/","tags":[["Linux","/tags/Linux/"],["ROS","/tags/ROS/"]],"categories":[["undefined",""]],"content":"ROS使用rviz rviz作用 rviz启动 rviz使用 程序测试 编译 运行 更多参考： rviz作用rviz相当于一个消息订阅者，可以将消息进行可视化显示 rviz启动必须先启动roscore，然后再启动rviz rviz使用点击界面左下方的 add ,出现添加可视化物体的选项框 选择 Marker ，点击 OK ，界面左边将会增加一个Marker 至此，在rviz中创建了一个subscriber，他目前接受并显示来自visualization_marker话题的消息 Marker是一个用来标记的东西，给定marker一个position和orientation（位置和姿态），那么rviz就会在中间画图区域的指定位置生成一个指定方向的marker 程序测试 pub_marker_msgs.cpp 程序的作用是接收chatterPoseStamped话题的消息，然后通过 visualization_msgs::Marker 发布出来，这样rviz中的Marker接收到消息就可以显示出来了 知识点： 程序中的 spub_marker_ = nh.advertise&lt;visualization_msgs::Marker&gt;(&quot;visualization_marker&quot;, 10) 发布的消息话题应为rviz中左侧Displays窗口中Marker&gt;&gt; Marker Topic的值 程序中的 set_marker_fixed_property() 设置了Marker的一些基本属性 程序中的 marker_.header.frame_id 的值需要等于rviz中左侧Displays窗口中Global Options&gt;&gt; Fixed Frame的值 编译编辑 CMakeLists.txt 文件 CMakeLists.txt中添加 编译 运行第一个终端启动roscore 第二个终端启动rviz 然后按照之前的方式添加一个Marker 第三个终端启动pub_marker_msgs节点 这个节点是转发功能，还需要有消息源 第四个终端启动pub_posestamped 之后，将会在rviz界面上看到有Marker生成 "},{"title":"ROS使用rosbag","date":"2021-08-04T12:58:33.000Z","url":"/ROS%E4%BD%BF%E7%94%A8rosbag/2021/08/04/","tags":[["Linux","/tags/Linux/"],["ROS","/tags/ROS/"]],"categories":[["undefined",""]],"content":"ROS使用rosbag rosbag作用 rosbag记录消息 第一个终端 第二个终端 第三个终端 rosbag重新发布记录的消息 第一个终端 第二个终端 第三个终端 更多参考： rosbag作用rosbag是ros系统用来储存消息的工具 一般来说，一般来说ros节点publisher发布的消息被其他节点subscriber订阅到并马上处理了。但是，如果想要将发布的消息进行储存以供后续分析，rosbag就是一个很好的工具，主要功能有两个： 记录消息 、 重新发布记录的消息 rosbag记录消息 在运行rosbag之前必须先启动roscore， record 表示记录需要保存消息， /chatter 指定保存消息的频道，可以指定多个消息频道， -O 指定记录消息的储存文件，如果是 -o ，那么记录名字会自动加上年月日时间，在终端按下 Ctrl+C 即可结束记录数据 第一个终端 第二个终端 运行一个发布消息的节点用于测试 第三个终端 rosbag重新发布记录的消息 play 表示重新发布记录的消息，后面跟一个记录的 .bag 包文件 运行对应节点subscriber后，即可模拟当时的消息实况 如未编写对应的节点程序或日志上对消息内容查看不方便，可以使用ros系统的另一个工具rostopic查看 第一个终端 第二个终端 第三个终端 "},{"title":"ROS使用roslaunch","date":"2021-08-04T12:39:20.000Z","url":"/ROS%E4%BD%BF%E7%94%A8roslaunch/2021/08/04/","tags":[["Linux","/tags/Linux/"],["ROS","/tags/ROS/"]],"categories":[["undefined",""]],"content":"ROS使用roslaunch roslaunch多节点启动 配置 启动 roslaunch参数传递(一) 配置 读取 编译 运行 roslaunch参数传递(二) 更多参考： roslaunch多节点启动配置在功能包目录下创建 launch 文件夹，在文件夹中新建一个文件，后缀名必须为 .launch test.launch roslaunch是使用xml语言 &lt;launch&gt; , &lt;\\launch&gt; 表示文件的开始和结束 &lt;node&gt; , &lt;\\node&gt; 表示节点相关内容 name表示节点的名字 pkg表示功能包的名字 type表示节点程序可执行文件名称 如果需要把一个可执行文件同时作为数个节点运行，就需要给他们不同的节点名，即配置相同的type不同的name。使用rqt_graph观察时，节点名称会变成launch文件配置的名称而非ros::ini()配置的名称。 启动 roslaunch参数传递(一)配置编辑test.launch &lt;param&gt; , &lt;\\param&gt; , &lt;rosparam&gt; , &lt;\\rosparam&gt; 是两种定义的参数的方式，如果标签在 node 内部，那么就表示这个参数是私有的 name表示参数的名字 type表示参数的类型 value表示参数的值 读取 read_param_test.cpp 编译编辑 CMakeLists.txt 文件 CMakeLists.txt中添加 编译 运行 roslaunch参数传递(二)除了在 .launch 文件添加参数标签外，还可以通过 .yaml 文件进行阐述传递 编辑test.launch 在package功能包中创建read_param_test.yaml .yaml 文件具有固定的格式 变量名: 变量值 ，不需要指定变量类型，变量值包含非数字量会被认为是string类型，纯数字的值，如果不包含小数则会被认为是int类型，包含小数则会被认为是double类型"},{"title":"ROS发布订阅消息（四）","date":"2021-08-04T12:37:37.000Z","url":"/ROS%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF%EF%BC%88%E5%9B%9B%EF%BC%89/2021/08/04/","tags":[["Linux","/tags/Linux/"],["ROS","/tags/ROS/"]],"categories":[["undefined",""]],"content":"ROS发布订阅消息（四） 发布订阅PoseStamped类型消息 PoseStamped PoseStamped结构 创建程序 编译 注意事项 运行 第一个终端 第二个终端 第三个终端 发布订阅PoseStamped类型消息PoseStampedPoseStamped是ROS自己独特的message类型，被包含在geometry_msgs这个大类下 Pose表示机器人的位姿(position and orientation) Stamped表示时间戳(timestamped)，指格林威治时间1970年01月01日00时00分00秒起至现在的总纳秒 需要添加头文件 #include &quot;geometry_msgs/PoseStamped.h&quot; PoseStamped结构示例代码 uint32 seq: 序列ID，默认会连续增加 time stamp: 时间戳 int32 sec: 时间戳，单位秒 int32 nsec: 时间戳，单位纳秒 实际时间应为 string frame_id: 目前看到为空，还不知道什么作用 Point position: 位置，包含xyz坐标(float64) Quaternion orientation: 姿态，以四元数形式表现，包含xyzw数据(float64) 创建程序 pub_posestamped.cpp sub_posestamped.cpp 编译编辑 CMakeLists.txt 文件 CMakeLists.txt中添加 编译 注意事项在编译过程中可能会出现找不到依赖包 geometry_msgs 的情况，需要添加依赖包，详细操作参照第一章 运行与上一章节类似 第一个终端 第二个终端 第三个终端 此时，在第三个终端将会打印发送的字符串，第二个终端会打印接收到的字符串 "},{"title":"ROS发布订阅消息（三）","date":"2021-08-04T12:36:20.000Z","url":"/ROS%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF%EF%BC%88%E4%B8%89%EF%BC%89/2021/08/04/","tags":[["Linux","/tags/Linux/"],["ROS","/tags/ROS/"]],"categories":[["undefined",""]],"content":"ROS发布订阅消息（三） 发布订阅double数组类型消息 注意事项 编译 运行 第一个终端 第二个终端 第三个终端 发布订阅double数组类型消息与上一章节发布订阅字符串类型相似 pub_float64multiarray.cpp sub_float64multiarray.cpp 注意事项在ROS中，是不能将数组的值直接赋值给msg.data，需要通过 std::vector&lt;T&gt; 来实现 编译编辑 CMakeLists.txt 文件 CMakeLists.txt中添加 编译 运行与上一章节类似 第一个终端 第二个终端 第三个终端 此时，在第三个终端将会打印发送的字符串，第二个终端会打印接收到的字符串 "},{"title":"ROS发布订阅消息（二）","date":"2021-08-04T12:35:05.000Z","url":"/ROS%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF%EF%BC%88%E4%BA%8C%EF%BC%89/2021/08/04/","tags":[["Linux","/tags/Linux/"],["ROS","/tags/ROS/"]],"categories":[["undefined",""]],"content":"ROS发布订阅消息（二） 发布订阅int类型消息 不同之处 编译 运行 第一个终端 第二个终端 第三个终端 发布订阅int类型消息与上一章节发布订阅字符串类型相似 pub_int8.cpp sub_int8.cpp 不同之处头文件不同的数据类型相应的需要包含不同的头文件，详见 其他类型的数据类似，包含的头文件位于 /opt/ros/melodic/include/std_msgs/ 发布者订阅者节点名称ROS系统中，节点名称应该唯一。ROS遇到了相同的节点名字那么他会停止掉旧节点的名字然后使用新节点的那个程序 消息话题为了与之前的消息区分，修改话题名称，可对消息进行区分 消息内容数据类型不一致嘛，这就是不一样啊 编译编辑 CMakeLists.txt 文件 CMakeLists.txt中添加 编译 运行与上一章节类似 第一个终端 第二个终端 第三个终端 此时，在第三个终端将会打印发送的字符串，第二个终端会打印接收到的字符串 "},{"title":"ROS发布订阅消息（一）","date":"2021-08-04T12:30:04.000Z","url":"/ROS%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF%EF%BC%88%E4%B8%80%EF%BC%89/2021/08/04/","tags":[["Linux","/tags/Linux/"],["ROS","/tags/ROS/"]],"categories":[["undefined",""]],"content":"ROS发布订阅消息（一） ROS常用概念 创建一个工作空间 创建一个package包 创建第一个ROS程序 消息发布 消息接收 编译第一个ROS程序 执行第一个ROS程序 第一个终端 第二个终端 第三个终端 第四个终端 ROS常用概念 message: 消息，机器人需要传感器，传感器采集到的信息，即这儿的message，通俗理解为传输的数据 topic： 话题，用来区分不同的message，可类比成通讯的频道 node： 节点，通常来讲你写的c++或者python程序主函数所在的程序称为一个节点 package： 一个ROS package包含了你要完成的一个项目的所有文件 workspace： ROS的工作空间，可以存放多个项目 publish, subscribe： ROS很大的一个作用就是传递message client, server： ROS另一个很大的一个作用就是远程过程调用和服务 创建一个工作空间 catkin_make 命令用于构建工作空间中的代码 第一次构建时工作空间时会生成两个新的文件夹 build 和 devel ， build 时cmake和make指令执行的地方， devel 是保存生成文件、目标的地方，以及用于安装的setup.sh 创建一个package包 catkin_create_pkg 命令用于创建一个ROS功能包，使用方法如下 &lt;package_name&gt; 为ROS功能包的名字，可以自定义 [depend1] 、[depend2]、 [depend3] 是创建该软件功能包所需的特定软件功能包，一般称为依赖包 如果刚开始的时候添加的依赖包不足，可在后期进行修改添加，主要修改文件 catkin_ws/src/&lt;package_name&gt;/CMakeLists.txt 和 catkin_ws/src/&lt;package_name&gt;/package.xml CMakeLists.txt找到如下内容，进行添加相应的依赖包 package.xml找到如下内容，按照其他的依赖包的形式样例添加 创建第一个ROS程序使用官方例子()进行学习 消息发布 pub_string.cpp 消息接收 sub_string.cpp 编译第一个ROS程序进入创建的功能包目录中，编辑 CMakeLists.txt 文件 打开文件后，里面内容有很多，找到 ##Declare a C++ executable 注释的地方后，添加下列代码 add_executable 为添加一个执行文件，pub_string 为生成可执行文件，src/pub_string.cpp 为源文件 target_link_libraries 为将可执行文件链接到一个库，$&#123;catkin_LIBRARIES&#125; 为链接的ROS库 编译 执行第一个ROS程序第一个终端 第二个终端 rosrun 是运行一个单独节点的命令 第三个终端 此时，在第三个终端将会打印发送的字符串，第二个终端会打印接收到的字符串 第四个终端此时，打开第四个终端，输入 将会有一个如同下图的节点关系图，能用于分析消息的走向 "},{"title":"Ubuntu18安装ROS","date":"2021-07-26T11:25:16.000Z","url":"/Ubuntu18%E5%AE%89%E8%A3%85ROS/2021/07/26/","tags":[["Linux","/tags/Linux/"],["ROS","/tags/ROS/"],["Ubuntu","/tags/Ubuntu/"]],"categories":[["undefined",""]],"content":"Ubuntu18安装ROS 配置软件仓库 安装ROS 更新安装列表 安装ros 初始化rosdep 初始化 加载环境 创建工作目录并初始化 构建项目 设置环境变量 ROS测试 运行ROSdemo 配置软件仓库打开 软件和更新 &gt;&gt; Ubuntu软件 ，可从互联网下载的选项全部勾选，关闭 控制台添加sources.list 添加keys 安装ROS更新安装列表 安装ros 初始化rosdep 此时很大概率会出现 需要修改hosts文件，以管理员权限打开 /etc/hosts 文件,在文件最末端添加 151.101.228.133 raw.githubusercontent.com ，其中的IP需要修改为电脑ping raw.github.com的IP 此时很大概率会失败，需要离线安装 修改 /etc/ros/rosdep/20-default.list 文件 修改 /usr/lib/python2.7/dist-packages/rosdistro/__init__.py 文件，修改内容 修改完文件后，重新update 初始化加载环境 创建工作目录并初始化 构建项目目前，只有src目录和CMakeLists.txt文件在catkin工作目录中，使用catkin_make命令来构建 至此，工作目录 catkin_ws 中只有 src 和CMakeList.txt ，需要通过 catkin_make 命令来构建项目 设置环境变量打开 gedit ~/.bashrc 文件，在文件末端添加以下代码 ROS测试运行ROSdemo打开三个控制台，分别运行下列各行代码 将会出现小乌龟界面，且通过键盘上的方向键可以控制小乌龟移动 "},{"title":"VM12安装Ubuntu18虚拟机","date":"2021-07-24T09:49:35.000Z","url":"/VM12%E5%AE%89%E8%A3%85Ubuntu18%E8%99%9A%E6%8B%9F%E6%9C%BA/2021/07/24/","tags":[["Linux","/tags/Linux/"],["Ubuntu","/tags/Ubuntu/"],["VM","/tags/VM/"]],"categories":[["undefined",""]],"content":"VM12安装Ubuntu18虚拟机 VM12主页点击 新建虚拟机 虚拟机类型选择 典型 ，下一步 选择 稍后安装操作系统 注意： 如果这里直接选择安装程序光盘映像文件的话，会直接安装虚拟机，系统界面语言为英文，后期想要调成中文比较麻烦 操作系统选择 Linux(L) ，版本选择 Ubuntu 64位 输入虚拟机名称，以及选择虚拟机存放的位置，下一步 设置最大磁盘大小，下一步 选择 自定义硬件 调整内存大小 处理器核数 新CD/DVD(SATA)选择需要安装的Ubuntu18.iso镜像文件 显示器中 加速3D图形 的选项去掉，关闭 完成 回到主页，点击打开此虚拟机 在弹窗左侧中选择 中文(简体) ，点击使用Ubuntu 注意： 当前分辨率过小，以及希望断网安装，选择试用可以进行相关设置，如果直接选择安装的话，会在之后的硬盘分区步骤中无法显示下一步 点击右上角，点击设置 选择设备 选择显示 修改稍大点的分辨率，应用 设置中选择网络，关闭 注意： 安装的时候如果联网，将会从网上下载更新，时间很久，可以关闭网络，这样比较快 点击桌面的 安装Ubuntu 图标 点击继续 选择键盘布局，点击继续 选择正常安装，点击继续 选择其他选项，手动分区，点击继续 新建分区表，按照需求进行分区，点击现在安装 地点选择上海，点击继续 输入身份信息，点击继续 等待安装 安装完成后选择现在重启，或关机 如果出现下图黑屏信息，可以按 CTRL + ALT 调出鼠标，选择关闭客户机 双击 CD/DVD(SATA) 连接属性修改为使用物理驱动器 重新打开此虚拟机 系统第一次欢迎弹窗，可以一直前进，完成 控制台输入 控制台输入 安装VMwareTools 双击桌面的VMwareTools，需要将里面的文件拷贝出来，且需要将压缩包进行提取 找到VMwareTool的安装文件，控制台输入 第一次询问是否安装，输入 Yes 回车，之后基本都是直接回车即可 安装完成，重启虚拟机，基本上就可以进行显示分辨率自适应，物理机与虚拟机文件之间的拖拉了 "},{"title":"Hexo插入目录","date":"2021-07-24T02:46:25.000Z","url":"/Hexo%E6%8F%92%E5%85%A5%E7%9B%AE%E5%BD%95/2021/07/24/","tags":[["Hexo","/tags/Hexo/"]],"categories":[["undefined",""]],"content":"Hexo插入目录 安装hexo-toc插件 修改配置文件_config.yml 使用 注意 安装hexo-toc插件在hexo根目录打开Git Bash，执行 修改配置文件_config.yml在配置文件中增加 使用在Markdown中需要显示文章目录的地方添加下面代码即可 注意目录在各个编辑器中可能存在不一样，如 csdn： typora： "},{"title":"Hexo插入图片","date":"2021-07-24T02:16:29.000Z","url":"/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/2021/07/24/","tags":[["Hexo","/tags/Hexo/"]],"categories":[["undefined",""]],"content":"Hexo插入图片 安装hexo-asset-image插件 修改配置文件_config.yml 修改.js文件 插入图片 安装hexo-asset-image插件在hexo根目录打开Git Bash，执行 修改配置文件_config.yml在配置文件中找到 post_asset_folder ，把这个选项从 false 改成 true 修改.js文件打开 /node_modules/hexo-asset-image/index.js 文件，替换为以下代码 插入图片在 source/_posts 生成 photo.md 文件和 photo 文件夹，我们把要插入的图片复制到 photo 文件夹内，在 photo.md 文件里面按markdown的标准写即可 "},{"title":"好用的免费软件清单","date":"2021-07-20T23:22:13.000Z","url":"/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%85%8D%E8%B4%B9%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/2021/07/21/","tags":[["软件清单","/tags/%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/"]],"categories":[["undefined",""]],"content":"好用的免费软件清单 输入法 Rime 截图软件 flameshot 录屏软件 Kazam 文件搜索 everything 图形绘制软件 yEd GIMP 视频编辑软件 Kdenlive 机械设计软件 LibreCAD FreeCAD 电路设计软件 KiCAD 输入法Rime操作系统： Linux、Windows、Mac OS 是否开源/免费： 免费开源 官方网站：  开源地址：  简述： Rime是一款简洁、高效、无广告的开源输入法。支持拼音、五笔、双拼、粤拼、繁体字等。在Linux下名称叫中州韵，Window下名称叫小狼毫，Mac OS下 截图软件flameshot操作系统： Linux 是否开源/免费： 免费开源 官方网站：  开源地址：  简述： flameshot是一款Linux下的截图软件，类似于微信截图，可以拖拽，画线等，可以保存到本地或粘贴板 录屏软件Kazam操作系统： Linux 是否开源/免费： 免费开源 官方网站：  开源地址：  简述： Kazam是一款截图录屏组合的软件，支持录全屏、指定窗口、指定区域，声源支持系统声音、麦克风声音、组合声音等 文件搜索everything操作系统： window 是否开源/免费： 免费不开源 官方网站：  简述： everything是一款window下的文件搜索软件，特点是简单、快。如果Linux下，可以使用 sudo updatedb + mlocate 进行搜索 图形绘制软件yEd操作系统： Linux、window、Mac OS 是否开源/免费： 免费不开源 官方网站：  简述： yEd是一款方便、快捷的图形绘制软件，与viso类似，可以绘制网络拓扑，人物关系，流程图等，体积比viso小 GIMP操作系统： Linux、window、Mac OS 是否开源/免费： 免费开源 官方网站：  开源网站：  简述： GIMP是一款图形处理软件，类似于PS 视频编辑软件Kdenlive操作系统： Linux、window、Mac OS 是否开源/免费： 免费开源 官方网站：  开源网站：  机械设计软件LibreCAD操作系统： Linux、window、Mac OS 是否开源/免费： 免费开源 官方网站：  开源网站：  简述： LibreCAD是一款制图软件，类似于autoCAD FreeCAD操作系统： Linux、window、Mac OS 是否开源/免费： 免费开源 官方网站：  开源网站：  简述： FreeCAD是一款开源的参数化三维建模软件，可以符合基本的工程制图需求 电路设计软件KiCAD操作系统： Linux、window、Mac OS 是否开源/免费： 免费开源 官方网站：  开源网站：  简述： KiCAD是一款开源的EDA软件，许多其他EDA软件在这上面都是以插件形式存在，由于开源，很多开发者提供了特别有意思的插件 "},{"title":"Linux下git安装与使用","date":"2021-07-20T13:22:43.000Z","url":"/Linux%E4%B8%8Bgit%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/2021/07/20/","tags":[["Linux","/tags/Linux/"],["git","/tags/git/"]],"categories":[["undefined",""]],"content":"Linux下git安装与使用 系统环境 git安装 git使用 git配置 .gitignore文件 git仓库初始化 git状态查看 git添加文件 git首次提交修改 git查看历史 git再次提交修改 git撤销修改 git列出分支 git新建分支 git切换分支 git合并分支 git删除分支 git克隆 git推送远程仓库 git拉取远程仓库 系统环境 git安装控制台输入指令 git使用git配置git在项目修改时需要跟踪，必须提供用户名，邮箱地址可以真实或虚拟 .gitignore文件.gitignore文件用来忽略被指定的文件或文件夹的改动 语法 # 注释 忽略文件/文件夹 ! 不忽略文件/文件夹 * 匹配任意字符 ? 匹配一个字符 [] 匹配括号内的单个字符，可是使用 - 表示连贯字符 ，使用 ^ 表示排除字符 git仓库初始化 仓库初始化后，将会建立一个 .git 文件夹，用于跟踪整个项目 git状态查看 git添加文件 git首次提交修改 git查看历史 git再次提交修改 -a 不会提交新文件，只提交现有文件修改的内容 git撤销修改 git列出分支 git新建分支 git切换分支 git合并分支 git删除分支 git克隆 git推送远程仓库 git拉取远程仓库"},{"title":"树莓派搭建Hexo博客部署到github","date":"2021-07-20T12:51:31.000Z","url":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0github/2021/07/20/","tags":[["Hexo","/tags/Hexo/"],["Linux","/tags/Linux/"],["树莓派","/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"]],"categories":[["undefined",""]],"content":"树莓派搭建Hexo博客部署到github git Node.js Hexo 搭建博客 部署到github git安装git 配置git 查看git是否正确安装 正确情况应该输出 Node.js查看树莓派的架构 然后到node.js官网下载对应版本 解压文件 将所有文件移动到 /usr/local/node 下 建立软连接 查看node.js是否正确安装 正确情况应该输出 Hexo由于国内网速问题，npm 包管理器的速度慢，使用 npm 安装 cnpm 替代 npm 的功能 建立软连接 安装Hexo 建立软连接 查看hexo是否正确安装 正确情况应该输出 搭建博客创建一个博客的根目录 blog ，并进行初始化 启动hexo 启动成功后，在树莓派本地浏览器输入 localhost:4000 可以查看的初始博客 部署到github在github上建立一个仓库，仓库名称必须为 github用户名+ .github.io 在根目录 blog 下，输入 进入 _config.yml 文件末端，修改并保存 执行 正常情况下应该能在 localhost:4000 查看博客的本地预览情况 输入 Ctrl+C 退出 在提示中输入github用户名和密码，即可将博客推送至github仓库个人博客主页"}]